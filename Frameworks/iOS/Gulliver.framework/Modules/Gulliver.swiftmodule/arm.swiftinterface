// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2 (swiftlang-1103.0.32.1 clang-1103.0.32.29)
// swift-module-flags: -target armv7-apple-ios9.3 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name Gulliver
import AVFoundation
import AudioToolbox
import CloudKit
import CommonCrypto
import Compression
import CoreData
import CoreGraphics
import Foundation
import MessageUI
import ObjectiveC
import OpenAL
import Security
import Swift
import UIKit.UIGestureRecognizerSubclass
import UIKit
extension UIViewController {
  public class func fromStoryboard(_ name: Swift.String? = nil, bundle: Foundation.Bundle? = nil) -> Self
  public class func fromStoryboard<T>(class: T.Type, name: Swift.String, bundle: Foundation.Bundle?) -> T where T : UIKit.UIViewController
  @objc dynamic public var visibleContainedController: UIKit.UIViewController {
    @objc get
  }
}
extension UINavigationController {
  @objc override dynamic public var visibleContainedController: UIKit.UIViewController {
    @objc get
  }
}
extension UITabBarController {
  @objc override dynamic public var visibleContainedController: UIKit.UIViewController {
    @objc get
  }
}
extension ContainerViewController {
  @objc override dynamic public var visibleContainedController: UIKit.UIViewController {
    @objc get
  }
}
extension UIViewController {
  open class func fromXIB(_ nibName: Swift.String? = nil, bundle: Foundation.Bundle? = nil) -> Self
  open class func controller() -> Self
  open class var nibName: Swift.String? {
    get
  }
  open class var storyboardName: Swift.String? {
    get
  }
  @objc dynamic open func navigationWrappedController(_ hideNavigationBar: Swift.Bool = false) -> UIKit.UINavigationController
  open func setTabOrder(_ order: [UIKit.UIView], withEndOfOrderClosure closure: ((UIKit.UIViewController) -> Swift.Void)?)
  open var tabOrder: [UIKit.UIView] {
    get
  }
  @objc dynamic open func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  open func setMaximumNumberOfCharactersForField(_ field: UIKit.UITextField, max: Swift.UInt?)
  open func maximumNumberOfCharactersForField(_ field: UIKit.UITextField) -> Swift.UInt?
  @objc(textField:shouldChangeCharactersInRange:replacementString:) dynamic open func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
}
extension UIViewController {
  public enum SlideDirection : Swift.String {
    case left
    case top
    case right
    case bottom
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  open var container: UIKit.UIViewController {
    get
  }
  @objc dynamic open func dismissFromBarButtonItem(completion: (() -> Swift.Void)? = nil)
}
extension UIViewController : UIKit.UITextFieldDelegate {
}
extension NSMutableAttributedString {
  public func append(image: UIKit.UIImage?, scaledToCurrentSize: Swift.Bool)
}
extension NSManagedObjectContext {
  public func encapsulate<T>(_ object: T, perform: @escaping (T) -> Swift.Void) where T : CoreData.NSManagedObject
  public func insertEntity(named name: Swift.String) -> CoreData.NSManagedObject
  public func count(of entityName: Swift.String, matching predicate: Foundation.NSPredicate? = nil) -> Swift.Int
  @objc dynamic public func saveContext(wait: Swift.Bool = true, toDisk: Swift.Bool = false, suppressInsertedNotifications: Swift.Bool = false, ignoreHasChanges: Swift.Bool = false, completion: ((Swift.Error?) -> Swift.Void)? = nil)
  public func refreshAllFaults()
  public func generateFetchRequest(for name: Swift.String) -> CoreData.NSFetchRequest<CoreData.NSFetchRequestResult>
  public func instantiate<T>(_ object: T?) -> T? where T : CoreData.NSManagedObject
  public func insertObject(named entityName: Swift.String) -> CoreData.NSManagedObject?
  public func insertObject<T>(entity: T.Type) -> T? where T : CoreData.NSManagedObject
  public func insertObject<T>() -> T? where T : CoreData.NSManagedObject
  public func fetchAll<T>(matching predicate: Foundation.NSPredicate? = nil, sortedBy: [Foundation.NSSortDescriptor] = []) -> [T] where T : CoreData.NSManagedObject
  public func fetchAll(named entityName: Swift.String, matching predicate: Foundation.NSPredicate? = nil, sortedBy: [Foundation.NSSortDescriptor] = []) -> [CoreData.NSManagedObject]
  public func fetchAny<T>(matching predicate: Foundation.NSPredicate? = nil, sortedBy sortBy: [Foundation.NSSortDescriptor] = []) -> T? where T : CoreData.NSManagedObject
  public func fetchAny(named entityName: Swift.String, matching predicate: Foundation.NSPredicate? = nil, sortedBy sortBy: [Foundation.NSSortDescriptor] = []) -> CoreData.NSManagedObject?
  public func delete(named entityName: Swift.String, matching predicate: Foundation.NSPredicate, singleRecord: Swift.Bool = true) throws -> Swift.Bool
  public func fetch(fields: [Swift.String], from entityName: Swift.String, matching predicate: Foundation.NSPredicate? = nil) -> [[Swift.String : Any]]
  public func fetch(field: Swift.String, from entityName: Swift.String, matching predicate: Foundation.NSPredicate? = nil) -> [Any]
}
extension NSAttributedString {
  public class var defaultAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
    set(newValue)
  }
  public func byAppending(string: Foundation.NSAttributedString) -> Foundation.NSAttributedString
  public func draw(centeredIn rect: CoreGraphics.CGRect)
  public func byAppending(string: Swift.String, attributes: [Foundation.NSAttributedString.Key : Any]? = nil) -> Foundation.NSAttributedString
  public var trailingAttributes: [Foundation.NSAttributedString.Key : Any]? {
    get
  }
}
extension NSMutableAttributedString {
  public func append(string: Swift.String, attributes: [Foundation.NSAttributedString.Key : Any]? = nil)
  public func createLink(atUniqueString string: Swift.String, to url: Foundation.URL)
  public func appendLink(title: Swift.String, to url: Foundation.URL, attributes: [Foundation.NSAttributedString.Key : Any]? = nil)
  public func assign(attributes attr: [Foundation.NSAttributedString.Key : Any], toUniqueSubstring text: Swift.String, replacing: Swift.Bool = true)
}
extension NSMutableAttributedString {
  public typealias StringAttributePair = (string: Swift.String, attributes: [Foundation.NSAttributedString.Key : Any])
  public convenience init?(_ pairs: [Foundation.NSMutableAttributedString.StringAttributePair])
  public convenience init(components: [Any])
}
@_hasMissingDesignatedInitializers public class GlobalState<Type> : Gulliver.ClassicNotifier, Swift.CustomStringConvertible where Type : Swift.Equatable {
  @objc deinit
  final public let initial: Type
  public var previous: Type
  public var current: Type {
    get
    set(value)
  }
  final public let desc: Swift.String
  public var description: Swift.String {
    get
  }
  public init(_ value: Type, description: Swift.String, watcher: ((Type) -> Swift.Void)? = nil)
  public func watchValue(tiedTo: Gulliver.Watchable? = nil, block: @escaping (Type) -> Swift.Void) -> ObjectiveC.NSObject
  public func watchValue(observer: Gulliver.Watchable, action: ObjectiveC.Selector)
  public func notify(value: Type, forceCurrentThread: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers public class Dispatcher {
  public init(identifier: Swift.String = "customDISPATCHQueue", serial: Swift.Bool = true)
  public static var main: Gulliver.DispatcherMain
  @available(OSX 10.10, *)
  public static var userInteractive: Gulliver.Dispatcher
  @available(OSX 10.10, *)
  public static var userInitiated: Gulliver.Dispatcher
  @available(OSX 10.10, *)
  public static var utility: Gulliver.Dispatcher
  @available(OSX 10.10, *)
  public static var background: Gulliver.Dispatcher
  public func sync(closure: () -> Swift.Void)
  public func async(closure: @escaping () -> Swift.Void)
  public static var inMainQueue: Swift.Bool {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DispatcherMain : Gulliver.Dispatcher {
  public func now(closure: @escaping () -> Swift.Void)
  public func asap(closure: @escaping () -> Swift.Void)
  override public func async(closure: @escaping () -> Swift.Void)
  public func wait(_ interval: Foundation.TimeInterval, closure: @escaping () -> Swift.Void)
  override public init(identifier: Swift.String = super, serial: Swift.Bool = super)
  @objc deinit
}
extension UIAlertController {
  public convenience init(title: Swift.String, message: Swift.String? = nil, buttons: [Swift.String] = [.OK], block: ((Swift.Int) -> Swift.Void)? = { action in })
}
extension UIViewController {
  public enum SlideDestination {
    case none
    case left(CoreGraphics.CGFloat)
    case top(CoreGraphics.CGFloat)
    case right(CoreGraphics.CGFloat)
    case bottom(CoreGraphics.CGFloat)
    case center(CoreGraphics.CGFloat, CoreGraphics.CGFloat)
  }
  public struct ResizeDimension : Swift.OptionSet {
    public init(rawValue: Swift.Int)
    public let rawValue: Swift.Int
    public static var horizontally: UIKit.UIViewController.ResizeDimension
    public static var none: UIKit.UIViewController.ResizeDimension
    public typealias Element = UIKit.UIViewController.ResizeDimension
    public typealias ArrayLiteralElement = UIKit.UIViewController.ResizeDimension
    public typealias RawValue = Swift.Int
  }
  open func slideIn(from origin: UIKit.UIViewController.SlideDirection, in parent: UIKit.UIViewController, to destination: UIKit.UIViewController.SlideDestination = .none, resize: UIKit.UIViewController.ResizeDimension = .horizontally, duration: Foundation.TimeInterval = 0.2, dismissOnOutsideTap: Swift.Bool = false, blockerColor: UIKit.UIColor = UIColor.dimmedBackground, completion: (() -> Swift.Void)? = nil)
  open func slideOut(backTo: UIKit.UIViewController.SlideDirection? = nil, duration: Foundation.TimeInterval = 0.2, completion: (() -> Swift.Void)? = nil)
}
extension UIWindow {
  public convenience init(basedOn: UIKit.UIViewController?, application: UIKit.UIApplication? = nil)
}
public class ImageAsciizer {
  public init(image: CoreGraphics.CGImage)
  @objc deinit
}
public struct DeviceIdentifier {
  public static var identifier: Swift.String {
    get
  }
}
extension Bundle {
  public func image(named: Swift.String, compatibleWith: UIKit.UITraitCollection? = nil) -> UIKit.UIImage?
}
public class Docket : Swift.CustomStringConvertible, Swift.Equatable {
  public typealias Tag = Swift.String
  public var cancelled: Swift.Bool
  public var completed: Swift.Bool
  public var logSteps: Swift.Bool
  public var completionQueue: Dispatch.DispatchQueue?
  public var pendingTags: [Gulliver.Docket.Tag]
  @objc deinit
  public init(_ label: Swift.String, queue: Dispatch.DispatchQueue? = nil, completion: @escaping () -> Swift.Void)
  public static func == (lhs: Gulliver.Docket, rhs: Gulliver.Docket) -> Swift.Bool
  public func addCompletion(_ completion: @escaping () -> Swift.Void)
  @discardableResult
  public func increment(tag: Gulliver.Docket.Tag) -> Gulliver.Docket
  public func isWaiting(for tag: Gulliver.Docket.Tag) -> Swift.Bool
  public func wait(for tag: Gulliver.Docket.Tag, closure: @escaping () -> Swift.Void)
  @discardableResult
  public func decrement(tag: Gulliver.Docket.Tag, optionally: Swift.Bool = false) -> Gulliver.Docket
  public func cancel()
  public var description: Swift.String {
    get
  }
}
public protocol DefaultsBasedPreferencesKeyProvider : AnyObject {
  var keys: [Swift.String : Swift.String] { get }
}
@_inheritsConvenienceInitializers @objc open class DefaultsBasedPreferences : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
  open func clearValue(forKey key: Swift.String)
  open func name(forKey key: Swift.String) -> Swift.String
  public func hasValue(forKey key: Swift.String) -> Swift.Bool
  open var defaults: Foundation.UserDefaults {
    get
  }
  @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  open func notificationName(forKey key: Swift.String) -> Foundation.Notification.Name
}
public protocol KVC {
  func valueForKey(key: Swift.String) -> Any?
}
extension KVC {
  public func valueForKey<T>(key: Swift.String) -> T?
  public func valueFor<T>(path: Swift.String) -> T?
}
extension NSObject {
  public func addAsObserver(forString name: Swift.String, selector sel: ObjectiveC.Selector, object: Any? = nil)
  @nonobjc public func addAsObserver(for name: Foundation.NSNotification.Name, selector sel: ObjectiveC.Selector, object: Any? = nil)
  public func removeAsObserver(forString notificationName: Swift.String)
  public func removeAsObserver(for notificationName: Foundation.NSNotification.Name? = nil)
}
extension NSObject {
  public func associate(object: Any?, forKey key: Swift.StaticString)
  public func associatedObject(forKey key: Swift.StaticString) -> Any?
}
extension NSObject {
  public func replace(selector first: ObjectiveC.Selector, with second: ObjectiveC.Selector)
}
extension UINavigationController {
  @objc override dynamic open var childForStatusBarStyle: UIKit.UIViewController? {
    @objc get
  }
}
public func delay(delay: Swift.Double?, closure: @escaping () -> ())
public func dispatch_async_main(closure: @escaping () -> ())
public func measure(label: Swift.String? = nil, block: @escaping () -> ())
public class DispatchTimer {
  public var cancelled: Swift.Bool
  public init(queue: Dispatch.DispatchQueue? = nil, interval: Dispatch.DispatchTimeInterval, repeats: Swift.Bool = false, execute: @escaping () -> Swift.Void)
  public func cancel()
  public func fire()
  public func reset()
  @objc deinit
}
public protocol UserDefaultsStorable {
}
extension String : Gulliver.UserDefaultsStorable {
}
extension Data : Gulliver.UserDefaultsStorable {
}
extension Date : Gulliver.UserDefaultsStorable {
}
extension Float : Gulliver.UserDefaultsStorable {
}
extension Double : Gulliver.UserDefaultsStorable {
}
extension Bool : Gulliver.UserDefaultsStorable {
}
extension Int : Gulliver.UserDefaultsStorable {
}
extension NSObject : Gulliver.UserDefaultsStorable {
}
public struct DefaultsKey<T> where T : Gulliver.UserDefaultsStorable {
  public let key: Swift.String
  public init(_ k: Swift.String)
}
extension UserDefaults {
  public subscript(key: Gulliver.DefaultsKey<Swift.String>) -> Swift.String? {
    get
    set(newValue)
  }
  public subscript(key: Gulliver.DefaultsKey<Foundation.Data>) -> Foundation.Data? {
    get
    set(newValue)
  }
  public subscript(key: Gulliver.DefaultsKey<Foundation.Date>) -> Foundation.Date? {
    get
    set(newValue)
  }
  public subscript(key: Gulliver.DefaultsKey<Swift.Int>) -> Swift.Int {
    get
    set(newValue)
  }
  public subscript(key: Gulliver.DefaultsKey<Swift.Float>) -> Swift.Float {
    get
    set(newValue)
  }
  public subscript(key: Gulliver.DefaultsKey<Swift.Bool>) -> Swift.Bool {
    get
    set(newValue)
  }
  public subscript(key: Gulliver.DefaultsKey<Swift.Double>) -> Swift.Double {
    get
    set(newValue)
  }
  public subscript(key: Gulliver.DefaultsKey<ObjectiveC.NSObject>) -> ObjectiveC.NSObject? {
    get
    set(newValue)
  }
  public func hasValueForKey(key: Swift.String) -> Swift.Bool
  public func removeValue(forKey key: Swift.String)
  public func clearValue<T>(forKey key: Gulliver.DefaultsKey<T>) where T : Gulliver.UserDefaultsStorable
}
extension UserDefaults {
  public class func setCurrentDefaults(group: Swift.String)
  public class func defaults() -> Foundation.UserDefaults
  public class func get(_ key: Gulliver.DefaultsKey<Swift.Int>) -> Swift.Int
  public class func set(_ value: Swift.Int?, forKey key: Gulliver.DefaultsKey<Swift.Int>)
  public class func get(_ key: Gulliver.DefaultsKey<Swift.Float>) -> Swift.Float
  public class func set(_ value: Swift.Float?, forKey key: Gulliver.DefaultsKey<Swift.Float>)
  public class func get(_ key: Gulliver.DefaultsKey<Swift.Double>) -> Swift.Double
  public class func set(_ value: Swift.Double?, forKey key: Gulliver.DefaultsKey<Swift.Double>)
  public class func get(_ key: Gulliver.DefaultsKey<Swift.Bool>) -> Swift.Bool
  public class func set(_ value: Swift.Bool?, forKey key: Gulliver.DefaultsKey<Swift.Bool>)
  public class func get(_ key: Gulliver.DefaultsKey<Swift.String>) -> Swift.String?
  public class func set(_ value: Swift.String?, forKey key: Gulliver.DefaultsKey<Swift.String>)
  public class func get(_ key: Gulliver.DefaultsKey<ObjectiveC.NSObject>) -> ObjectiveC.NSObject?
  public class func set(_ value: ObjectiveC.NSObject?, forKey key: Gulliver.DefaultsKey<ObjectiveC.NSObject>)
  public class func get(_ key: Gulliver.DefaultsKey<Foundation.Data>) -> Foundation.Data?
  public class func set(_ value: Foundation.Data?, forKey key: Gulliver.DefaultsKey<Foundation.Data>)
  public class func get(_ key: Gulliver.DefaultsKey<Foundation.Date>) -> Foundation.Date?
  public class func set(_ value: Foundation.Date?, forKey key: Gulliver.DefaultsKey<Foundation.Date>)
  public class func hasValue(forKey key: Swift.String) -> Swift.Bool
  public class func clearValue<T>(forKey key: Gulliver.DefaultsKey<T>) where T : Gulliver.UserDefaultsStorable
}
public class Pending<T> : Gulliver.StringLike {
  public init(_ fetch: @escaping () -> T)
  public func fulfill() -> T?
  public var string: Swift.String {
    get
  }
  @objc deinit
}
public protocol StringLike {
  var string: Swift.String { get }
}
public protocol DoubleLike {
  var double: Swift.Double { get }
}
public protocol IntLike {
  var int: Swift.Int { get }
}
public protocol FloatLike {
  var float: Swift.Float { get }
}
extension String : Gulliver.StringLike {
  public var string: Swift.String {
    get
  }
}
extension Double : Gulliver.DoubleLike {
  public var double: Swift.Double {
    get
  }
}
extension Int : Gulliver.IntLike {
  public var int: Swift.Int {
    get
  }
}
extension Float : Gulliver.FloatLike {
  public var float: Swift.Float {
    get
  }
}
extension UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
  public var b1: Swift.UInt8 {
    get
  }
  public var b2: Swift.UInt8 {
    get
  }
  public var b3: Swift.UInt8 {
    get
  }
  public var b4: Swift.UInt8 {
    get
  }
  public static func random(to max: Swift.UInt32) -> Swift.UInt32
}
@objc @_inheritsConvenienceInitializers open class SA_ViewController : UIKit.UIViewController {
  @objc dynamic public convenience init()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension UIView {
  public var parentScrollView: UIKit.UIScrollView? {
    get
  }
  public class func view(nibName: Swift.String? = nil, bundle: Foundation.Bundle? = nil) -> UIKit.UIView?
  public var contentCenter: CoreGraphics.CGPoint {
    get
  }
  public func resignFirstResponderForAllSubviews()
  public func removeBlockingView(duration: Foundation.TimeInterval, completion: (() -> Swift.Void)? = nil)
  public func blockingView(excluding: [CoreGraphics.CGRect] = [], tappedClosure closure: (() -> Swift.Void)? = nil) -> UIKit.UIView
  public var viewController: UIKit.UIViewController? {
    get
  }
  public var tableViewCell: UIKit.UITableViewCell? {
    get
  }
  public func hierarchy(_ prefix: Swift.String? = nil) -> Swift.String
  public func isAncestor(view: UIKit.UIView?) -> Swift.Bool
  public func snapshot(frame: CoreGraphics.CGRect? = nil, afterScreenUpdates: Swift.Bool = true) -> UIKit.UIImage?
}
extension UIView {
  public func setupBorder(color: UIKit.UIColor, width: CoreGraphics.CGFloat = 1.0, radius: CoreGraphics.CGFloat? = nil)
  public func setupShadow(color: UIKit.UIColor = UIColor.black, radius: CoreGraphics.CGFloat = 3.0, offset: CoreGraphics.CGSize = CGSize(width: 3, height: 3), opacity: Swift.Float = 0.5)
}
public func IF_DEBUG(closure: () -> ())
public func measure(label: Swift.String, closure: () -> ())
public func dprint(_ items: Any..., separator: Swift.String = "", terminator: Swift.String = "\n")
extension ManagedObjectStore {
  public func clearMetadata()
  open subscript(key: Swift.String) -> Any? {
    get
    set(newValue)
  }
}
extension Character {
  public var utf8Value: Swift.UInt8 {
    get
  }
  public var utf16Value: Swift.UInt16 {
    get
  }
  public var unicodeValue: Swift.UInt32 {
    get
  }
  public var intValue: Swift.Int {
    get
  }
}
extension Array {
  public func contains<Element>(_ obj: Element) -> Swift.Bool where Element : Swift.Equatable
  public subscript(safe index: Swift.Int) -> Element? {
    get
  }
  public func any() -> Element?
  @discardableResult
  public mutating func remove<U>(_ object: U) -> [Element] where U : Swift.Equatable
  public func index<T>(of obj: T) -> Swift.Int? where T : Swift.Equatable
}
extension Array {
  public var random: Element? {
    get
  }
}
extension Array where Element : Swift.Equatable {
  @_hasMissingDesignatedInitializers public class Differences : Swift.CustomStringConvertible {
    final public let added: [Element]
    final public let removed: [Element]
    final public let remained: [Element]
    public var description: Swift.String {
      get
    }
    @objc deinit
  }
  public func differences(fromOlder target: [Element]?) -> Swift.Array<Element>.Differences
  public func differences(toNewer target: [Element]?) -> Swift.Array<Element>.Differences
}
extension UIColor {
  public static var dimmedBackground: UIKit.UIColor
  public static var darkDimmedBackground: UIKit.UIColor
  public convenience init?(hex: Swift.String)
  public var hex: Swift.String {
    get
  }
  public func swatch(ofSize size: CoreGraphics.CGSize = CGSize(width: 1, height: 1)) -> UIKit.UIImage?
}
extension UIColor {
  public var rgba: Swift.UInt32 {
    get
  }
  public var argb: Swift.UInt32 {
    get
  }
  public convenience init(rgba: Swift.UInt32)
  public convenience init(argb: Swift.UInt32)
  public class func random() -> UIKit.UIColor
  public var contrastingTextColor: UIKit.UIColor {
    get
  }
}
extension String {
  public func width(font: UIKit.UIFont) -> CoreGraphics.CGFloat
  public func height(font: UIKit.UIFont, constrainedToWidth: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
}
extension NSAttributedString {
  public var width: CoreGraphics.CGFloat {
    get
  }
  public func height(constrainedToWidth: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
}
extension UIImage {
  public var md5: Swift.String {
    get
  }
}
extension Data {
  public var md5: Swift.String {
    get
  }
  public var sha256: Swift.String {
    get
  }
}
extension String {
  public var md5: Swift.String {
    get
  }
  public var sha256: Swift.String {
    get
  }
}
extension URL {
  public var md5: Swift.String? {
    get
  }
  public var sha256: Swift.String? {
    get
  }
}
public protocol CanBeEmpty {
  var isEmpty: Swift.Bool { get }
}
extension Array : Gulliver.CanBeEmpty {
}
extension Dictionary : Gulliver.CanBeEmpty {
}
extension Set : Gulliver.CanBeEmpty {
}
extension String : Gulliver.CanBeEmpty {
}
extension Optional where Wrapped : Gulliver.CanBeEmpty {
  public var isEmpty: Swift.Bool {
    get
  }
  public func value(or fallback: Wrapped) -> Wrapped
}
extension Optional where Wrapped : Swift.OptionSet {
  public func contains(_ option: Wrapped.Element) -> Swift.Bool
}
extension Optional where Wrapped == Swift.Bool {
  public var isTrue: Swift.Bool {
    get
  }
  public var isFalse: Swift.Bool {
    get
  }
}
extension Timer {
  public class func scheduledOnMainThread(interval: Foundation.TimeInterval, target: Swift.AnyObject, selector: ObjectiveC.Selector, userInfo: Swift.AnyObject?, repeats: Swift.Bool) -> Foundation.Timer
  @available(iOS 10.0, iOSApplicationExtension 10.0, OSX 10.12, *)
  public struct DeferredAction {
    public var completion: (() -> Swift.Void)
    weak public var timer: Foundation.Timer?
    public var interval: Foundation.TimeInterval
    public init(after delay: Foundation.TimeInterval = 0, completion: @escaping () -> Swift.Void = { })
    public func fire()
    public mutating func delay(for interval: Foundation.TimeInterval? = nil, completion: (() -> Swift.Void)? = nil)
  }
}
extension FileManager {
  public func fileExists(at url: Foundation.URL?) -> Swift.Bool
  public func directoryExists(at url: Foundation.URL) -> Swift.Bool
  public func fileNotDirectoryExists(at url: Foundation.URL) -> Swift.Bool
  public class func userDirectory(type: Foundation.FileManager.SearchPathDirectory) -> Foundation.URL?
  public static var documentsDirectoryURL: Foundation.URL {
    get
  }
  public static var libraryDirectoryURL: Foundation.URL {
    get
  }
  public static var applicationSupportDirectoryURL: Foundation.URL {
    get
  }
  public static var applicationSpecificSupportDirectoryURL: Foundation.URL {
    get
  }
  public static var cachesDirectoryURL: Foundation.URL {
    get
  }
  public static var tempDirectoryURL: Foundation.URL {
    get
  }
  public static func randomFileName(extension ext: Swift.String = "dat") -> Swift.String
  public static func tempFileURL(extension ext: Swift.String = "dat") -> Foundation.URL
}
extension URL {
  public var directoryPath: Gulliver.DirectoryPath? {
    get
  }
}
public class DirectoryPath : Swift.CustomStringConvertible, Swift.Equatable {
  public enum Error : Swift.Error {
    case movedToTrashReturnedInvalidURL
    public static func == (a: Gulliver.DirectoryPath.Error, b: Gulliver.DirectoryPath.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let url: Foundation.URL
  public var path: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public var fileSystemRepresentation: Swift.UnsafePointer<Swift.Int8> {
    get
  }
  public static func == (lhs: Gulliver.DirectoryPath, rhs: Gulliver.DirectoryPath) -> Swift.Bool
  public static var documents: Gulliver.DirectoryPath
  public static var library: Gulliver.DirectoryPath
  public static var caches: Gulliver.DirectoryPath
  public init(path: Swift.String, createPathIfNecessary: Swift.Bool = false)
  public init?(url: Foundation.URL, createPathIfNecessary: Swift.Bool = false)
  public var `extension`: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public init(parent: Gulliver.DirectoryPath, component: Swift.String, createPathIfNecessary: Swift.Bool = false) throws
  public func subdirectory(_ name: Swift.String, createPathIfNecessary: Swift.Bool = false) throws -> Gulliver.DirectoryPath
  public func child(_ name: Swift.String, createPathIfNecessary: Swift.Bool = false) throws -> Gulliver.FilePath
  public var parent: Gulliver.DirectoryPath? {
    get
  }
  public func path(relativeTo: Gulliver.FilePath) -> Swift.String?
  public func relativePath(to relativeTo: Foundation.URL) -> Swift.String?
  public subscript(name: Swift.String) -> Foundation.Data? {
    get
    set(newValue)
  }
  public subscript(name: Swift.String) -> Gulliver.FilePath? {
    get
    set(newValue)
  }
  public subscript<Type>(name: Swift.String) -> Type? where Type : Swift.Decodable, Type : Swift.Encodable {
    get
    set(newValue)
  }
  public var children: [Gulliver.DirectoryPath] {
    get
  }
  public func remove() throws
  public var exists: Swift.Bool {
    get
  }
  public func create(withoutPredjudice: Swift.Bool = false, attributes: [Foundation.FileAttributeKey : Any]? = nil) throws
  public func isEqual(to other: Gulliver.DirectoryPath) -> Swift.Bool
  @objc deinit
}
public class FilePath : Gulliver.DirectoryPath {
  public struct FileType : Swift.Equatable {
    public static var unknown: Gulliver.FilePath.FileType
    public static var gif: Gulliver.FilePath.FileType
    public static var png: Gulliver.FilePath.FileType
    public static var jpeg: Gulliver.FilePath.FileType
    public static var zip: Gulliver.FilePath.FileType
    public static var lzf: Gulliver.FilePath.FileType
    public static var pdf: Gulliver.FilePath.FileType
    public static func == (lhs: Gulliver.FilePath.FileType, rhs: Gulliver.FilePath.FileType) -> Swift.Bool
  }
  override public var description: Swift.String {
    get
  }
  override public var exists: Swift.Bool {
    get
  }
  public var data: Foundation.Data? {
    get
    set(newValue)
  }
  public func set(data: Foundation.Data?) throws
  override public init(parent: Gulliver.DirectoryPath, component: Swift.String, createPathIfNecessary: Swift.Bool = false) throws
  override public init?(url: Foundation.URL, createPathIfNecessary: Swift.Bool = false)
  public func copy(from: Gulliver.FilePath) throws
  public func read<T>(count: Swift.Int) -> Swift.UnsafeMutablePointer<T>?
  public func readLast<T>(count: Swift.Int) -> Swift.UnsafeMutablePointer<T>?
  public var fileType: Gulliver.FilePath.FileType? {
    get
  }
  @objc deinit
  override public init(path: Swift.String, createPathIfNecessary: Swift.Bool = super)
}
extension ManagedObjectStore {
  public func switchDatabaseName(to newName: Swift.String) throws
}
extension ManagedObjectStore {
  public func setupModel()
  public func setupMainThreadContext()
  public func setupPeristentStore()
  public func unregister(context: CoreData.NSManagedObjectContext?)
}
public protocol SaveableToDisk : AnyObject {
  associatedtype Content : Swift.Decodable, Swift.Encodable
  var content: Self.Content { get set }
  var savedFilename: Swift.String { get }
  var saveToDirectory: Foundation.URL { get }
  func saveToDisk(_ content: Self.Content?) throws
  @discardableResult
  func loadFromDisk() throws -> Self.Content
}
extension SaveableToDisk {
  public var saveToDirectory: Foundation.URL {
    get
  }
  public func saveToDisk(_ content: Self.Content? = nil) throws
  @discardableResult
  public func loadFromDisk() throws -> Self.Content
}
extension CGRect {
  public func rect(inset insets: UIKit.UIEdgeInsets) -> CoreGraphics.CGRect
}
extension UIEdgeInsets {
  public var totalH: CoreGraphics.CGFloat {
    get
  }
  public var totalV: CoreGraphics.CGFloat {
    get
  }
}
extension Int {
  public static func random(to max: Swift.UInt32) -> Swift.Int
}
extension UIView {
  public var isDraggable: Swift.Bool {
    get
    set(newValue)
  }
}
public func log(level: Gulliver.Logger.Level = .debugOnly, _ closure: @autoclosure () -> Swift.String)
public func log(level: Gulliver.Logger.Level = .debugOnly, _ item: Any?)
public func log(level: Gulliver.Logger.Level = .debugOnly, _ error: Swift.Error?, note: Swift.String? = nil, evenIfNoError: Swift.Bool = false)
@_hasMissingDesignatedInitializers public class Logger {
  public static var state: Gulliver.Logger.State
  public enum State : Swift.Int {
    case production
    case testing
    case debugging
    case fixing
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Level : Swift.Int {
    case all
    case testingOnly
    case debugOnly
    case verbose
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public static var prefix: Swift.String
  public static func log(level: Gulliver.Logger.Level = .debugOnly, _ closure: @autoclosure () -> Swift.String)
  public static func log(level: Gulliver.Logger.Level = .debugOnly, _ item: Any?)
  public static func log(level: Gulliver.Logger.Level = .debugOnly, _ error: Swift.Error?, note: Swift.String? = nil, evenIfNoError: Swift.Bool = false)
  @objc deinit
}
public protocol StringError : Swift.CustomStringConvertible, Swift.Error {
}
extension StringError where Self : Swift.RawRepresentable, Self.RawValue : Swift.ExpressibleByStringLiteral {
  public var description: Swift.String {
    get
  }
}
public protocol NoteWorthy {
  var isNoteWorthy: Swift.Bool { get }
}
@_hasMissingDesignatedInitializers public class ErrorLogger {
  public struct notifications {
    public static var errorLogged: Foundation.Notification.Name
    public static var errorsCleared: Foundation.Notification.Name
  }
  public static var errorLogPrefix: Swift.String
  public static var errorLogSuffix: Swift.String
  public static var shouldLogToConsole: Swift.Bool
  public class var areErrorsAvailable: Swift.Bool {
    get
  }
  @discardableResult
  public class func log(_ error: Swift.Error?, _ label: Swift.String? = nil) -> Swift.Bool
  public class func clearLog()
  public class var numberOfAvailableErrors: Swift.Int {
    get
  }
  public static var errorSound: Gulliver.SoundEffect? {
    get
    set(value)
  }
  @objc deinit
}
@objc open class ManagedObjectStore : ObjectiveC.NSObject {
  public enum Configuration : Swift.String {
    case production
    case testing
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  final public let modelURL: Foundation.URL?
  open var model: CoreData.NSManagedObjectModel!
  public var persistentStoreCoordinator: CoreData.NSPersistentStoreCoordinator!
  public var mainThreadContext: CoreData.NSManagedObjectContext!
  public var privateContext: CoreData.NSManagedObjectContext!
  public var importContext: CoreData.NSManagedObjectContext!
  public var groupIdentifier: Swift.String?
  public var storeURL: Foundation.URL!
  public var databaseURL: Foundation.URL!
  public var persistentStoreOptions: [Swift.String : Any]
  public var managedObjectContextClass: Gulliver.DataStoreContext.Type
  public var serializer: Dispatch.DispatchQueue
  public var databaseFileExists: Swift.Bool {
    get
  }
  public var dataDirectoryExists: Swift.Bool {
    get
  }
  public var configuration: Gulliver.ManagedObjectStore.Configuration {
    get
    set(value)
  }
  public var isSetup: Swift.Bool {
    get
  }
  public init(dbFilename: Swift.String, modelURL: Foundation.URL? = nil, groupIdentifier: Swift.String? = nil, options: [Swift.String : Any] = [:])
  open func buildDatabaseName(from base: Swift.String) -> Swift.String
  open func setup()
  open func didCreateDatabase()
  open func didSetupContext()
  open func createWorkerContext(name: Swift.String = "Worker Context") -> CoreData.NSManagedObjectContext
  open func perform(with block: @escaping (CoreData.NSManagedObjectContext) -> Swift.Void)
  open func performAndWait(with block: @escaping (CoreData.NSManagedObjectContext) -> Swift.Void)
  open func didSaveMainContext()
  @objc deinit
  @objc override dynamic public init()
}
@objc open class DataStoreContext : CoreData.NSManagedObjectContext {
  required public init(store: Gulliver.ManagedObjectStore, concurrencyType: CoreData.NSManagedObjectContextConcurrencyType)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func saveContext(wait: Swift.Bool, toDisk: Swift.Bool, suppressInsertedNotifications: Swift.Bool, ignoreHasChanges: Swift.Bool, completion: ((Swift.Error?) -> Swift.Void)?)
  @objc deinit
  @available(iOS 5.0, *)
  @objc override dynamic public init(concurrencyType ct: CoreData.NSManagedObjectContextConcurrencyType)
}
@_hasMissingDesignatedInitializers public class Timing : Swift.CustomStringConvertible {
  public class func start(key: Swift.String = #function, file: Swift.String = #file) -> Gulliver.Timing
  public class func lap(note: Swift.String? = nil, key: Swift.String = #function) -> Gulliver.Timing?
  public class func stop(key: Swift.String = #function)
  public class func time(title: Swift.String? = nil, iterations: Swift.Int = 10, block: () -> Swift.Void)
  public func lap(note: Swift.String? = nil)
  public func stop()
  public func logString() -> Swift.String
  public func logTimes()
  public var description: Swift.String {
    get
  }
  public var averageLapDuration: Foundation.TimeInterval {
    get
  }
  @objc deinit
}
infix operator ?= : AssignmentPrecedence
infix operator ∆= : AssignmentPrecedence
public func ?= <T>(left: inout T, right: T?)
public func ?= <T>(left: inout T?, right: T?)
@discardableResult
public func ∆= <T>(left: inout T, right: T) -> T where T : Swift.Equatable
@discardableResult
public func ∆= <T>(left: inout T?, right: T) -> T? where T : Swift.Equatable
public var M_2xPI: Swift.Double
public var rad2deg_factor: Swift.Double
public func rad2deg(_ rad: Swift.Double) -> Swift.Double
public func deg2rad(_ deg: Swift.Double) -> Swift.Double
@objc @_inheritsConvenienceInitializers public class SALongPressGestureRecognizer : UIKit.UIGestureRecognizer {
  public var shouldPlayTapticFeedback: Swift.Bool
  public var tolerance: CoreGraphics.CGFloat
  public var interval: Foundation.TimeInterval
  public convenience init(interval: Foundation.TimeInterval = .pressAndHoldInterval, completion: @escaping (Gulliver.SALongPressGestureRecognizer) -> Swift.Void)
  @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc override dynamic open func reset()
  @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc override dynamic public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc deinit
}
extension Encodable {
  public var asJSONData: Foundation.Data? {
    get
  }
  public func saveJSON(to url: Foundation.URL) throws
  public func saveJSON(toUserDefaults key: Swift.String) throws
}
extension Decodable {
  public static func load(fromJSONData data: Foundation.Data) throws -> Self
  public static func loadJSON(from url: Foundation.URL) throws -> Self
  public static func loadJSON(fromUserDefaults key: Swift.String) throws -> Self
}
public struct ThreadsafeArrayGenerator<Element> : Swift.IteratorProtocol {
  public mutating func next() -> Element?
}
extension ThreadsafeArray where Element : Swift.Equatable {
  public func contains(item: Element) -> Swift.Bool
  public mutating func remove(_ item: Element)
  public func index(of item: Element) -> Swift.Int?
}
public struct ThreadsafeArray<Element> : Swift.Sequence, Swift.ExpressibleByArrayLiteral {
  public func makeIterator() -> Gulliver.ThreadsafeArrayGenerator<Element>
  public var array: [Element]
  public init(_ starter: [Element] = [])
  public init(arrayLiteral: Element...)
  public subscript(index: Swift.Int) -> Element {
    get
    set(newValue)
  }
  public mutating func sort(by comparison: (Element, Element) throws -> Swift.Bool) rethrows
  public var count: Swift.Int {
    get
  }
  public mutating func append(_ element: Element)
  public mutating func remove(at index: Swift.Int)
  public func map<U>(closure: (Element) -> (U)) -> [U]
  public func flatMap<U>(closure: (Element) -> (U)) -> [U]
  public var values: [Element] {
    get
  }
  public var first: Element? {
    get
  }
  public var last: Element? {
    get
  }
  public mutating func removeAll()
  public mutating func append(_ elements: [Element])
  public func index(where check: (Element) -> Swift.Bool) -> Swift.Int?
  public typealias Iterator = Gulliver.ThreadsafeArrayGenerator<Element>
  public typealias ArrayLiteralElement = Element
}
public func += <Element>(lhs: Gulliver.ThreadsafeArray<Element>, rhs: [Element]) -> Gulliver.ThreadsafeArray<Element>
public func + <Element>(lhs: Gulliver.ThreadsafeArray<Element>, rhs: Gulliver.ThreadsafeArray<Element>) -> Gulliver.ThreadsafeArray<Element>
public func += <Element>(lhs: inout Gulliver.ThreadsafeArray<Element>, rhs: Gulliver.ThreadsafeArray<Element>)
public func + <Element>(lhs: Gulliver.ThreadsafeArray<Element>, rhs: [Element]) -> Gulliver.ThreadsafeArray<Element>
public func += <Element>(lhs: inout Gulliver.ThreadsafeArray<Element>, rhs: [Element])
public struct ThreadsafeDictionaryGenerator<Key, Element> : Swift.IteratorProtocol where Key : Swift.Hashable {
  public mutating func next() -> (Key, Element?)?
}
public struct ThreadsafeDictionary<Key, Value> : Swift.Sequence, Swift.ExpressibleByDictionaryLiteral where Key : Swift.Hashable {
  public func makeIterator() -> Gulliver.ThreadsafeDictionaryGenerator<Key, Value>
  public var dict: [Key : Value]
  public init(_ starter: [Key : Value] = [:])
  public init(dictionaryLiteral elements: (Key, Value)...)
  public var keys: Swift.Dictionary<Key, Value>.Keys {
    get
  }
  public var values: Swift.Dictionary<Key, Value>.Values {
    get
  }
  public subscript(key: Key) -> Value? {
    get
    set(newValue)
  }
  public var count: Swift.Int {
    get
  }
  public typealias Element = (Key, Swift.Optional<Value>)
  public typealias Iterator = Gulliver.ThreadsafeDictionaryGenerator<Key, Value>
}
@objc @_inheritsConvenienceInitializers public class SA_MailComposeViewController : MessageUI.MFMailComposeViewController, MessageUI.MFMailComposeViewControllerDelegate {
  public var completion: ((MessageUI.MFMailComposeResult) -> Swift.Void)? {
    get
    set(value)
  }
  public convenience init?(toAddress: Swift.String, subject: Swift.String? = nil, body: Swift.String? = nil, completion comp: ((MessageUI.MFMailComposeResult) -> Swift.Void)? = nil)
  @objc public func mailComposeController(_ controller: MessageUI.MFMailComposeViewController, didFinishWith result: MessageUI.MFMailComposeResult, error: Swift.Error?)
  @objc deinit
  @available(iOS 5.0, *)
  @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
}
public class AtomicValue<T> {
  public init(_ value: T)
  public var value: T {
    get
    set(newValue)
  }
  @objc deinit
}
public enum ImageFormat : Swift.String {
  case PNG
  case JPEG
  public var mimeType: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension UIImage {
  public enum ImageStoreError : Swift.Error {
    case nonLocalURL
    case unableToConverToData
    public static func == (a: UIKit.UIImage.ImageStoreError, b: UIKit.UIImage.ImageStoreError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public func store(in url: Foundation.URL) throws
  public convenience init?(contentsOf url: Foundation.URL)
  public func asciiImage(ofWidth: Swift.Int = 40) -> Swift.String?
  public class func create(size: CoreGraphics.CGSize, closure: (CoreGraphics.CGContext) -> Swift.Void) -> UIKit.UIImage?
  public func tintedImage(tint: UIKit.UIColor) -> UIKit.UIImage?
  public func scaledImage(scale: CoreGraphics.CGFloat) -> UIKit.UIImage
  public func resizedImage(size: CoreGraphics.CGSize, trimmed: Swift.Bool = true, changeScaleTo: CoreGraphics.CGFloat? = nil) -> UIKit.UIImage?
  public class func deviceLaunchImage(orientation: UIKit.UIDeviceOrientation = .unknown) -> UIKit.UIImage?
  public class func deviceLaunchImageURL(orientation: UIKit.UIDeviceOrientation = .unknown) -> Foundation.URL?
  public var hasAlpha: Swift.Bool {
    get
  }
}
extension UIImageView {
  public class func deviceLaunchImageView(orientation: UIKit.UIInterfaceOrientation = .unknown) -> UIKit.UIImageView?
}
@available(iOS 10.0, iOSApplicationExtension 10.0, *)
extension UIImage {
  public static func randomEmojiImage(face: Swift.Bool = false, ofSize size: CoreGraphics.CGSize, background color: UIKit.UIColor = .white) -> UIKit.UIImage?
}
extension Calendar {
  public static var gregorian: Foundation.Calendar {
    get
  }
}
extension UIScrollView {
  public static var gulliver_isListeningForKeyboardNotifications: Swift.StaticString
  public static var gulliver_keyboardForceSizeChangeCallback: Swift.StaticString
  public static var gulliver_scrollViewInitialContentInsetBottom: Swift.StaticString
  public var resizesForKeyboard: Swift.Bool {
    get
    set(newValue)
  }
  public func setResizesForKeyboard(resizes: Swift.Bool, heightChanged: @escaping (CoreGraphics.CGFloat) -> Swift.Void)
  public func callHeightShared(delta: CoreGraphics.CGFloat)
  @objc dynamic public func gulliver_keyboardWillShow(note: Foundation.NSNotification)
  @objc dynamic public func gulliver_keyboardWillHide(note: Foundation.NSNotification)
}
@_hasMissingDesignatedInitializers public class SoundEffect : Swift.Equatable {
  public static var disableAllSounds: Swift.Bool
  public var isPlaying: Swift.Bool
  public var isLooping: Swift.Bool {
    get
  }
  public var volume: Swift.Float {
    get
    set(value)
  }
  public init?(url: Foundation.URL, preload: Swift.Bool = true, uncached: Swift.Bool = false)
  public init?(data: Foundation.Data?, preload: Swift.Bool = true, uncached: Swift.Bool = false)
  @available(iOS 9.0, iOSApplicationExtension 9.0, OSX 10.11, *)
  public convenience init?(named name: Swift.String, in bundle: Foundation.Bundle? = nil, preload: Swift.Bool = true, uncached: Swift.Bool = false)
  public func loop(fadingInOver fadeIn: Foundation.TimeInterval = 0)
  public func stop(fadingOutOver fadeOut: Foundation.TimeInterval = 0)
  public static func == (lhs: Gulliver.SoundEffect, rhs: Gulliver.SoundEffect) -> Swift.Bool
  @objc deinit
}
extension SoundEffect {
  public var duration: Foundation.TimeInterval? {
    get
  }
  @discardableResult
  public func play(fadingInOver fadeIn: Foundation.TimeInterval = 0, completion: (() -> Swift.Void)? = nil) -> Swift.Bool
  public func pause()
}
extension UIBezierPath {
  public func appendString(string: Foundation.NSAttributedString, atPoint pt: CoreGraphics.CGPoint, withTransform: CoreGraphics.CGAffineTransform = CGAffineTransform.identity)
}
extension String {
  public init?(data: Foundation.Data?, encoding: Swift.String.Encoding = .ascii)
  public init(_ lines: Swift.String...)
  public static var OK: Swift.String
  public static var Cancel: Swift.String
  public var length: Swift.Int {
    get
  }
  public subscript(i: Swift.Int) -> Swift.Character {
    get
  }
  public subscript(i: Swift.Int) -> Swift.String {
    get
  }
  public subscript(range: Swift.Range<Swift.Int>) -> Swift.String {
    get
  }
  public func range(range: Swift.Range<Swift.Int>) -> Swift.Range<Swift.String.Index>
  public func range(range: Foundation.NSRange) -> Swift.Range<Swift.String.Index>
  public func index(_ index: Swift.Int) -> Swift.String.Index
  public var fullRange: Swift.Range<Swift.String.Index> {
    get
  }
  public var isValidEmail: Swift.Bool {
    get
  }
  public func stringByRemovingCharactersInSet(set: Foundation.CharacterSet) -> Swift.String
}
public func + (left: Swift.String?, right: Swift.String) -> Swift.String
public func + (left: Swift.String, right: Swift.String?) -> Swift.String
public func == (left: Swift.String, right: Swift.String?) -> Swift.Bool
public func == (left: Swift.String?, right: Swift.String) -> Swift.Bool
extension String {
  public var lastPathComponent: Swift.String {
    get
  }
  public var pathExtension: Swift.String {
    get
  }
  public func stringByAppendingPathComponent(comp: Swift.String) -> Swift.String
  public var stringByDeletingLastPathComponent: Swift.String {
    get
  }
  public var stringByDeletingPathExtension: Swift.String {
    get
  }
  public func stringByAppendingPathExtension(ext: Swift.String) -> Swift.String?
  public var stringByAbbreviatingWithTildeInPath: Swift.String {
    get
  }
  public var stringByExpandingTildeInPath: Swift.String {
    get
  }
}
extension String {
  public static func randomEmoji(facesOnly: Swift.Bool = false) -> Swift.String
}
extension Data {
  public var hexString: Swift.String {
    get
  }
  public init?(hexString hex: Swift.String)
  public var string: Swift.String? {
    get
  }
  public func string(using encoding: Swift.String.Encoding) -> Swift.String?
  public var fileType: Gulliver.FilePath.FileType? {
    get
  }
  public var imageFileExtension: Swift.String? {
    get
  }
}
public typealias ConstrainableView = UIKit.UIView
public typealias ConstrainableViewLayoutPriority = UIKit.UILayoutPriority
extension UIView {
  public func existingConstraint(for attr: UIKit.NSLayoutConstraint.Attribute) -> UIKit.NSLayoutConstraint?
  @discardableResult
  public func constrainJustified(in parent: Gulliver.ConstrainableView, priority: Swift.Float = 500) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func constrainWithin(parent: Gulliver.ConstrainableView, top: CoreGraphics.CGFloat? = nil, left: CoreGraphics.CGFloat? = nil, bottom: CoreGraphics.CGFloat? = nil, right: CoreGraphics.CGFloat? = nil, priority: Swift.Float = 500) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func constrain(width: CoreGraphics.CGFloat? = nil, height: CoreGraphics.CGFloat? = nil, priority: Swift.Float = 250) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func constrainCenter(offsetFromHorizontalCenter: CoreGraphics.CGFloat? = nil, offsetFromVerticalCenter: CoreGraphics.CGFloat? = nil, priority: Swift.Float = 250) -> [UIKit.NSLayoutConstraint]
  @discardableResult
  public func constrainDimension(_ attribute: UIKit.NSLayoutConstraint.Attribute, constant: CoreGraphics.CGFloat, priority: Swift.Float = 250, relation: UIKit.NSLayoutConstraint.Relation = .equal) -> [UIKit.NSLayoutConstraint]
  public func removeAutoResizingConstraints()
  @discardableResult
  public func constrain(spacingOn attr: UIKit.NSLayoutConstraint.Attribute, amount: CoreGraphics.CGFloat = 0, toView: Gulliver.ConstrainableView? = nil, side: UIKit.NSLayoutConstraint.Attribute? = nil, priority: Swift.Float = 250, relation: UIKit.NSLayoutConstraint.Relation = .equal) -> [UIKit.NSLayoutConstraint]
  public func removeAllConstraints()
}
extension OperationQueue {
  public convenience init(serial: Swift.Bool)
  public func addOperationAndWait(withBlock block: @escaping () -> Swift.Void)
}
extension UIBarButtonItem {
  public convenience init(spacerWith: CoreGraphics.CGFloat)
  public class func flexibleSpacer() -> UIKit.UIBarButtonItem
  @available(iOS 9.0, *)
  public convenience init(activityIndicator style: UIKit.UIActivityIndicatorView.Style, width: CoreGraphics.CGFloat = 44)
  public convenience init(image: UIKit.UIImage?, block: @escaping (UIKit.UIBarButtonItem) -> Swift.Void)
  public convenience init(title: Swift.String?, block: @escaping (UIKit.UIBarButtonItem) -> Swift.Void)
  public convenience init(barButtonSystemItem systemItem: UIKit.UIBarButtonItem.SystemItem, block: @escaping (UIKit.UIBarButtonItem) -> Swift.Void)
}
extension UITextField {
  public var maximumNumberOfCharacters: Swift.UInt? {
    get
    set(newValue)
  }
}
extension CKRecord {
  public class func removeAllRecords(type: Swift.String, inDatabase database: CloudKit.CKDatabase, completion: @escaping (Swift.Int, Swift.Error?) -> Swift.Void)
}
public struct WeakRef<Element> where Element : AnyObject {
  weak public var object: Element?
}
extension WeakRef : Swift.Hashable {
  public static func == (lhs: Gulliver.WeakRef<Element>, rhs: Gulliver.WeakRef<Element>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WeakArrayGenerator<Element> : Swift.IteratorProtocol where Element : AnyObject {
  public mutating func next() -> Element?
}
public struct WeakArray<Element> : Swift.Sequence, Swift.ExpressibleByArrayLiteral where Element : AnyObject {
  public func makeIterator() -> Gulliver.WeakArrayGenerator<Element>
  public var array: Swift.Array<Gulliver.WeakRef<Element>>
  public var count: Swift.Int {
    get
  }
  public mutating func append(_ object: Element)
  public init(_ starter: [Element] = [])
  public init(arrayLiteral: Element...)
  public subscript(index: Swift.Int) -> Element? {
    get
    set(newValue)
  }
  public mutating func remove(at index: Swift.Int)
  public var first: Element? {
    get
  }
  public var last: Element? {
    get
  }
  public typealias Iterator = Gulliver.WeakArrayGenerator<Element>
  public typealias ArrayLiteralElement = Element
}
public struct WeakSet<Element> : Swift.ExpressibleByArrayLiteral where Element : AnyObject, Element : Swift.Hashable {
  public init(arrayLiteral: Element...)
  public var count: Swift.Int {
    get
  }
  public mutating func insert(_ object: Element)
  public typealias ArrayLiteralElement = Element
}
public protocol DefaultReflectable : Swift.CustomStringConvertible {
}
extension DefaultReflectable {
  public var description: Swift.String {
    get
  }
}
extension CustomStringConvertible {
  public var defaultDescription: Swift.String {
    get
  }
  public var deepDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
@objc public protocol ProgressDisplayable {
  @objc var fractionCompleted: Swift.Double { get set }
  @objc var indeterminate: Swift.Bool { get set }
  @objc func progressDisplayBegan()
  @objc func progressDisplayCompleted()
}
@objc public protocol ProgressDisplayableView {
  @objc var fractionCompleted: Swift.Double { get set }
  @objc var view: UIKit.UIView { get }
  @objc var isIndeterminateDisplay: Swift.Bool { get }
}
extension Progress {
  public var isDisplayedProgress: Swift.Bool {
    get
    set(newValue)
  }
}
@objc public class ProgressDisplay : UIKit.UIView, Gulliver.ProgressDisplayable {
  @objc deinit
  public var title: Swift.String
  public var detailText: Swift.String
  public var buttonInfo: Gulliver.ProgressDisplayAction? {
    get
    set(value)
  }
  public var determinateView: Gulliver.ProgressDisplayableView? {
    get
    set(value)
  }
  public var indeterminateView: Gulliver.ProgressDisplayableView? {
    get
    set(value)
  }
  public var titleLabel: UIKit.UILabel!
  public var detailLabel: UIKit.UILabel!
  public var button: UIKit.UIButton?
  public var textColor: UIKit.UIColor
  public var closeWhenComplete: Swift.Bool
  public init(startingIn: UIKit.UIViewController?, title titleString: Swift.String? = nil, detailText detailString: Swift.String? = nil, determinateView dView: Gulliver.ProgressDisplayableView? = UIProgressView.progressDisplay(), indeterminateView iView: Gulliver.ProgressDisplayableView? = UIActivityIndicatorView.progressDisplay(), button: Gulliver.ProgressDisplayAction? = nil)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc public var fractionCompleted: Swift.Double {
    @objc get
    @objc set(value)
  }
  @objc public var indeterminate: Swift.Bool {
    @objc get
    @objc set(value)
  }
  public func close(_ animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil) -> Gulliver.ProgressDisplay
  @objc public func progressDisplayBegan()
  @objc public func progressDisplayCompleted()
  @discardableResult
  public func show(in parent: UIKit.UIViewController, animated: Swift.Bool = true) -> Gulliver.ProgressDisplay
  @discardableResult
  public func show(animated: Swift.Bool = true) -> Gulliver.ProgressDisplay
  @discardableResult
  public func hide(animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil) -> Gulliver.ProgressDisplay
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public struct ProgressDisplayAction {
  public let title: Swift.String
  public let action: (Gulliver.ProgressDisplay) -> Swift.Void
  public init(title titleString: Swift.String, action actionClosure: @escaping (Gulliver.ProgressDisplay) -> Swift.Void)
}
extension UIActivityIndicatorView : Gulliver.ProgressDisplayableView {
  @objc dynamic public var fractionCompleted: Swift.Double {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic public var view: UIKit.UIView {
    @objc get
  }
  @objc dynamic public var isIndeterminateDisplay: Swift.Bool {
    @objc get
  }
  public class func progressDisplay() -> UIKit.UIActivityIndicatorView
}
extension UIProgressView : Gulliver.ProgressDisplayableView {
  @objc dynamic public var fractionCompleted: Swift.Double {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic public var view: UIKit.UIView {
    @objc get
  }
  @objc dynamic public var isIndeterminateDisplay: Swift.Bool {
    @objc get
  }
  public class func progressDisplay() -> UIKit.UIProgressView
}
extension Error {
  public var isTimeout: Swift.Bool {
    get
  }
  public var isNoConnection: Swift.Bool {
    get
  }
  public var underlyingErrors: [Foundation.NSError] {
    get
  }
}
public enum CommonErrors : Swift.Error {
  case fileNotFound(Swift.String)
  case unableToReadData(Swift.String)
}
@objc @_inheritsConvenienceInitializers public class SA_AlertController : UIKit.UIAlertController {
  public func present(in presenter: UIKit.UIViewController?)
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidDisappear(_ animated: Swift.Bool)
  public func cancel(animated: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  public static var numberOfPendingAlerts: Swift.Int {
    get
  }
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension Date {
  public enum StringLength : Swift.Int {
    case normal
    case short
    case veryShort
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum DayOfWeek : Swift.Int {
    case sunday
    case monday
    case tuesday
    case wednesday
    case thursday
    case friday
    case saturday
    public var nextDay: Foundation.Date.DayOfWeek {
      get
    }
    public func increment(count: Swift.Int) -> Foundation.Date.DayOfWeek
    public var abbrev: Swift.String {
      get
    }
    public var shortName: Swift.String {
      get
    }
    public var name: Swift.String {
      get
    }
    public var isWeekendDay: Swift.Bool {
      get
    }
    public var isWeekDay: Swift.Bool {
      get
    }
    public static var firstDayOfWeek: Foundation.Date.DayOfWeek {
      get
    }
    public static var weekdays: [Foundation.Date.DayOfWeek] {
      get
    }
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Month : Swift.Int {
    case jan
    case feb
    case mar
    case apr
    case may
    case jun
    case jul
    case aug
    case sep
    case oct
    case nov
    case dec
    public var nextMonth: Foundation.Date.Month {
      get
    }
    public func increment(by: Swift.Int) -> Foundation.Date.Month
    public var abbrev: Swift.String {
      get
    }
    public var shortName: Swift.String {
      get
    }
    public var name: Swift.String {
      get
    }
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension Double {
  public static var secondsPerMinute: Foundation.TimeInterval
  public static var secondsPerHour: Foundation.TimeInterval
  public static var secondsPerDay: Foundation.TimeInterval
  public static var saveInterval: Foundation.TimeInterval
  public static var keyPressSearchDelay: Foundation.TimeInterval
  public static var pressAndHoldInterval: Foundation.TimeInterval
  public var days: Swift.Int {
    get
  }
  public var hours: Swift.Int {
    get
  }
  public var minutes: Swift.Int {
    get
  }
  public var seconds: Swift.Int {
    get
  }
}
infix operator ≈≈ : ComparisonPrecedence
infix operator !≈ : ComparisonPrecedence
public func ≈≈ (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
public func !≈ (lhs: Foundation.Date, rhs: Foundation.Date) -> Swift.Bool
extension Date {
  public func localTimeString(dateStyle: Foundation.DateFormatter.Style = .short, timeStyle: Foundation.DateFormatter.Style = .short) -> Swift.String
  public var isToday: Swift.Bool {
    get
  }
  public var isTomorrow: Swift.Bool {
    get
  }
  public var isYesterday: Swift.Bool {
    get
  }
  public func dateBySettingDate(date: Foundation.Date?) -> Foundation.Date
  public func dateBySettingTime(time: Foundation.Date?) -> Foundation.Date
  public var dateOnly: Foundation.Date {
    get
  }
  public var timeOnly: Foundation.Date {
    get
  }
  public var midnight: Foundation.Date {
    get
  }
  public var lastSecond: Foundation.Date {
    get
  }
  public var year: Swift.Int {
    get
  }
  public var month: Foundation.Date.Month {
    get
  }
  public var day: Swift.Int {
    get
  }
  public var hour: Swift.Int {
    get
  }
  public var minute: Swift.Int {
    get
  }
  public var second: Swift.Int {
    get
  }
  public var dayOfWeek: Foundation.Date.DayOfWeek {
    get
  }
  public func dayOfWeekString(length: Foundation.Date.StringLength = .short) -> Swift.String
  public var numberOfDaysInMonth: Swift.Int {
    get
  }
  public static func numberOfDays(in month: Foundation.Date.Month, year: Swift.Int) -> Swift.Int
  public var firstDayOfWeekInMonth: Foundation.Date.DayOfWeek {
    get
  }
  public var firstDayInMonth: Foundation.Date {
    get
  }
  public var lastDayInMonth: Foundation.Date {
    get
  }
  public func byAdding(seconds: Swift.Int? = nil, minutes: Swift.Int? = nil, hours: Swift.Int? = nil, days: Swift.Int? = nil, months: Swift.Int? = nil, years: Swift.Int? = nil) -> Foundation.Date
  public func byChanging(nanosecond: Swift.Int? = nil, second: Swift.Int? = nil, minute: Swift.Int? = nil, hour: Swift.Int? = nil, day: Swift.Int? = nil, month: Swift.Int? = nil, year: Swift.Int? = nil) -> Foundation.Date
  public var nextDay: Foundation.Date {
    get
  }
  public var previousDay: Foundation.Date {
    get
  }
  public var noon: Foundation.Date {
    get
  }
  public func isSameDayAs(other: Foundation.Date) -> Swift.Bool
}
extension Date {
  public static func ageString(age: Foundation.TimeInterval, style: Foundation.DateFormatter.Style = .short) -> Swift.String
}
extension Int {
  public var isLeapYear: Swift.Bool {
    get
  }
}
public typealias RectContentMode = UIKit.UIView.ContentMode
public func roundcgf(value: CoreGraphics.CGFloat) -> CoreGraphics.CGFloat
extension CGPoint {
  public func centeredRect(size: CoreGraphics.CGSize) -> CoreGraphics.CGRect
  public func square(side: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func adjustX(_ deltaX: CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
  public func adjustY(_ deltaY: CoreGraphics.CGFloat) -> CoreGraphics.CGPoint
  public func round() -> CoreGraphics.CGPoint
  public func distance(to other: CoreGraphics.CGPoint) -> CoreGraphics.CGFloat
}
public func - (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
public func + (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
extension CGSize {
  public enum AspectRatioType : Swift.Int {
    case portrait
    case landscape
    case square
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public func scaled(within limit: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public var isSquare: Swift.Bool {
    get
  }
  public var rect: CoreGraphics.CGRect {
    get
  }
  public func round() -> CoreGraphics.CGSize
  public var aspectRatio: CoreGraphics.CGFloat {
    get
  }
  public var aspectRatioType: CoreGraphics.CGSize.AspectRatioType {
    get
  }
  public func scaled(by factor: CoreGraphics.CGFloat) -> CoreGraphics.CGSize
  public func scaleDown(toWidth maxWidth: CoreGraphics.CGFloat?, height maxHeight: CoreGraphics.CGFloat?) -> CoreGraphics.CGSize
}
extension CGRect {
  public func scaled(to factor: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public init(x: CoreGraphics.CGFloat = 0, y: CoreGraphics.CGFloat = 0, size: CoreGraphics.CGSize)
  public init(origin: CoreGraphics.CGPoint, width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat)
  public var aspectRatio: CoreGraphics.CGFloat {
    get
  }
  public var aspectRatioType: CoreGraphics.CGSize.AspectRatioType {
    get
  }
  public var x: CoreGraphics.CGFloat {
    get
    set(newValue)
  }
  public var y: CoreGraphics.CGFloat {
    get
    set(newValue)
  }
  public var center: CoreGraphics.CGPoint {
    get
  }
  public func round() -> CoreGraphics.CGRect
  public func scaledRectWithAspectRatio(ratio: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func within(limit: CoreGraphics.CGRect, placed: Gulliver.RectContentMode) -> CoreGraphics.CGRect
  public var upperLeft: CoreGraphics.CGPoint {
    get
  }
  public var upperRight: CoreGraphics.CGPoint {
    get
  }
  public var lowerLeft: CoreGraphics.CGPoint {
    get
  }
  public var lowerRight: CoreGraphics.CGPoint {
    get
  }
  public func flippedVerticallyIn(frame: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  public func leading(percentage: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func trailing(percentage: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func upper(percentage: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func lower(percentage: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func leading(amount: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func trailing(amount: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func upper(amount: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func lower(amount: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
  public func offset(x: CoreGraphics.CGFloat = 0, y: CoreGraphics.CGFloat = 0) -> CoreGraphics.CGRect
  public func centerVertically(height: CoreGraphics.CGFloat) -> CoreGraphics.CGRect
}
extension CGContext {
  public func drawRadialGradient(from: CoreGraphics.CGColor, to: CoreGraphics.CGColor, in rect: CoreGraphics.CGRect)
}
extension Bundle {
  public var version: Swift.String {
    get
  }
  public var buildNumber: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var copyright: Swift.String {
    get
  }
}
extension NSObject {
  public var bundle: Foundation.Bundle? {
    get
  }
  public class var bundle: Foundation.Bundle? {
    get
  }
}
public protocol ContainerViewControllerDelegate : AnyObject {
  func willAnimate(controller: UIKit.UIViewController?, toPercentage: CoreGraphics.CGFloat, duration: Foundation.TimeInterval)
}
@objc @_inheritsConvenienceInitializers open class ContainerViewController : UIKit.UIViewController {
  public enum PresentationStyle : Swift.CustomStringConvertible {
    case none
    case crossFade(duration: Foundation.TimeInterval)
    case slideOver(from: UIKit.UIRectEdge, duration: Foundation.TimeInterval)
    case pushIn(from: UIKit.UIRectEdge, duration: Foundation.TimeInterval)
    public var description: Swift.String {
      get
    }
  }
  public var currentController: UIKit.UIViewController?
  public var currentPresentationStyle: Gulliver.ContainerViewController.PresentationStyle?
  public var previousControllers: [(animation: Gulliver.ContainerViewController.PresentationStyle, controller: UIKit.UIViewController)]
  public var canPopController: Swift.Bool {
    get
  }
  weak public var delegate: Gulliver.ContainerViewControllerDelegate?
  public var screenEdgePanGestureRecognizer: UIKit.UIScreenEdgePanGestureRecognizer!
  public convenience init(initialViewController: UIKit.UIViewController)
  public func pushContent(to controller: UIKit.UIViewController?, animation: Gulliver.ContainerViewController.PresentationStyle = .none, completion: (() -> ())? = nil)
  public func popContent(to controller: UIKit.UIViewController? = nil, animation: Gulliver.ContainerViewController.PresentationStyle = .none, completion: (() -> ())? = nil)
  public func setContent(to controller: UIKit.UIViewController?, animation: Gulliver.ContainerViewController.PresentationStyle = .none, replacingStack: Swift.Bool = false, completion: (() -> ())? = nil)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension URL {
  public static var aboutBlank: Foundation.URL
}
extension URL {
  public init?(realHomeDirectory: Swift.Bool)
  public init(fileURLByExpandingTildeInPath path: Swift.String)
}
open class Keychain {
  public static var instance: Gulliver.Keychain
  open var lastResultCode: Darwin.OSStatus
  open var accessGroup: Swift.String?
  open var synchronizable: Swift.Bool
  public init()
  public init(keyPrefix: Swift.String)
  @discardableResult
  open func set(_ value: Swift.String, forKey key: Swift.String, withAccess access: Gulliver.Keychain.AccessOptions? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.Data, forKey key: Swift.String, withAccess access: Gulliver.Keychain.AccessOptions? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Bool, forKey key: Swift.String, withAccess access: Gulliver.Keychain.AccessOptions? = nil) -> Swift.Bool
  open func get(_ key: Swift.String) -> Swift.String?
  open func getData(_ key: Swift.String) -> Foundation.Data?
  open func getBool(_ key: Swift.String) -> Swift.Bool?
  @discardableResult
  open func delete(_ key: Swift.String) -> Swift.Bool
  @discardableResult
  open func clear() -> Swift.Bool
  @objc deinit
}
extension Keychain {
  public struct Constants {
    public static var accessGroup: Swift.String {
      get
    }
    public static var accessible: Swift.String {
      get
    }
    public static var attrAccount: Swift.String {
      get
    }
    public static var attrSynchronizable: Swift.String {
      get
    }
    public static var keychainClass: Swift.String {
      get
    }
    public static var matchLimit: Swift.String {
      get
    }
    public static var returnData: Swift.String {
      get
    }
    public static var valueData: Swift.String {
      get
    }
  }
  public enum AccessOptions {
    case accessibleWhenUnlocked
    case accessibleWhenUnlockedThisDeviceOnly
    case accessibleAfterFirstUnlock
    case accessibleAfterFirstUnlockThisDeviceOnly
    case accessibleAlways
    case accessibleWhenPasscodeSetThisDeviceOnly
    case accessibleAlwaysThisDeviceOnly
    public static func == (a: Gulliver.Keychain.AccessOptions, b: Gulliver.Keychain.AccessOptions) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
extension NSManagedObject {
  public var didInsertNotificationName: Foundation.Notification.Name {
    get
  }
  public var didSaveAfterInsertionNotificationName: Foundation.Notification.Name {
    get
  }
  public var willDeleteNotificationName: Foundation.Notification.Name {
    get
  }
  public var didDeleteNotificationName: Foundation.Notification.Name {
    get
  }
  public class func entityName(in moc: CoreData.NSManagedObjectContext) -> Swift.String
}
@_inheritsConvenienceInitializers @objc open class SA_ManagedObject : CoreData.NSManagedObject {
  public class var didInsertNotificationName: Foundation.Notification.Name {
    get
  }
  public class var willDeleteNotificationName: Foundation.Notification.Name {
    get
  }
  public class var didDeleteNotificationName: Foundation.Notification.Name {
    get
  }
  public class var didSaveAfterInsertionNotificationName: Foundation.Notification.Name {
    get
  }
  @objc deinit
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
}
extension NSManagedObject {
  open subscript(key: Swift.String) -> Any? {
    get
    set(newValue)
  }
  open var moc: CoreData.NSManagedObjectContext? {
    get
  }
  open func instantiate(in moc: CoreData.NSManagedObjectContext) -> CoreData.NSManagedObject?
  open func logObject()
  open func refreshInContext(merge: Swift.Bool = true)
  open func save(wait: Swift.Bool = true, toDisk: Swift.Bool = true, completion: ((Swift.Error?) -> Swift.Void)? = nil)
  open func deleteFromContext(andSave: Swift.Bool = false)
  open func hasProperty(key: Swift.String) -> Swift.Bool
}
public func encapsulate<T>(_ object: T, perform: @escaping (T) -> Swift.Void) where T : CoreData.NSManagedObject
extension NSManagedObject {
  open var threadsafeToken: CoreData.NSManagedObject.ThreadsafeToken {
    get
  }
  @objc @_hasMissingDesignatedInitializers open class ThreadsafeToken : ObjectiveC.NSObject {
    final public let objectID: CoreData.NSManagedObjectID
    @objc deinit
    @objc override dynamic public init()
  }
}
extension Array where Element : CoreData.NSManagedObject {
  public var threadsafeTokens: [CoreData.NSManagedObject.ThreadsafeToken] {
    get
  }
}
extension NSManagedObjectContext {
  open func reconstitute<T>(_ token: CoreData.NSManagedObject.ThreadsafeToken?) -> T?
  open func reconstitute<T>(record: T?) -> T?
  open func reconstitute<T>(_ tokens: [CoreData.NSManagedObject.ThreadsafeToken]) -> [T]
}
extension NSManagedObject {
  open func load(dictionary dict: [Swift.String : Swift.AnyObject])
  open func importRelationship(name: Swift.String, fromDictionary dict: [Swift.String : Swift.AnyObject]) -> CoreData.NSManagedObject?
  open func findExistingRelationship(entityName: Swift.String, forDictionary dict: [Swift.String : Swift.AnyObject]) -> CoreData.NSManagedObject?
  open func addRelationship(name: Swift.String, fromDictionary dict: [Swift.String : Swift.AnyObject]) -> CoreData.NSManagedObject?
  open func dictionaryKeyToAttributeName(key: Swift.String) -> Swift.String?
  open func dictionaryStringToDate(string: Swift.String) -> Foundation.Date?
  public func dictionaryStringToBool(string: Swift.String) -> Swift.Bool?
}
@objc @_inheritsConvenienceInitializers public class TextDisplayViewController : UIKit.UIViewController {
  public var text: Swift.String {
    get
    set(value)
  }
  public class func show(text: Swift.String, in parent: UIKit.UIViewController)
  public convenience init(text: Swift.String, preferredSize: CoreGraphics.CGSize? = nil)
  @objc override dynamic public func viewDidLoad()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension UIDevice {
  public var isIPad: Swift.Bool {
    get
  }
}
extension NSNotification.Name {
  public func watch(_ object: Any, message: ObjectiveC.Selector)
}
extension Notification {
  public static func post(name: Swift.String, object: Any? = nil, userInfo: Foundation.NSDictionary? = nil)
  public static func post(name: Foundation.Notification.Name, object: Any? = nil, userInfo: Foundation.NSDictionary? = nil)
  public static func postOnMainThread(name: Swift.String, object: Any? = nil, userInfo: Foundation.NSDictionary? = nil)
  public static func postOnMainThread(name: Foundation.Notification.Name, object: Any? = nil, userInfo: Foundation.NSDictionary? = nil)
  @_hasMissingDesignatedInitializers public class Observation {
    @objc deinit
  }
}
public protocol Watchable : AnyObject {
}
extension NSObject : Gulliver.Watchable {
}
public typealias Notifier = Foundation.Notification.Name
extension NSNotification.Name {
  public func watch(_ observer: Any, message: ObjectiveC.Selector, object: Any? = nil)
  public func unwatch(_ observer: Any, object: Any? = nil)
  public func notify(_ object: Any? = nil, info: Foundation.NSDictionary? = nil, forceCurrentThread: Swift.Bool = false)
}
@_hasMissingDesignatedInitializers public class ClassicNotifier {
  @objc deinit
}
extension Array where Element : Swift.Equatable {
  public mutating func remove(contentsOf undesirables: Swift.Array<Element>)
}
extension Set {
  public mutating func remove(contentsOf undesirables: Swift.Array<Element>)
}
@_hasMissingDesignatedInitializers public class Deferred<T> : Gulliver.StringLike {
  public init(_ fetch: @escaping () -> T?)
  public func fulfill() -> T?
  public var string: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DeferredIn<T> : Gulliver.Deferred<T> {
  public init(context moc: CoreData.NSManagedObjectContext, fetch: @escaping (CoreData.NSManagedObjectContext) -> T?)
  @objc deinit
  override public init(_ fetch: @escaping () -> T?)
}
extension UIFont {
  public func sizeOfString(string: Swift.String, constrainedToWidth width: CoreGraphics.CGFloat) -> CoreGraphics.CGSize
}
extension NSParagraphStyle {
  public class func aligned(alignment: UIKit.NSTextAlignment) -> UIKit.NSMutableParagraphStyle
  public class var centered: UIKit.NSParagraphStyle {
    get
  }
}
extension NSMutableAttributedString {
  public func addLineBreakOfHeight(height: CoreGraphics.CGFloat)
}
extension UICollectionReusableView {
  open class var identifier: Swift.String {
    get
  }
  open class var nib: UIKit.UINib {
    get
  }
  open class var defaultNibName: Swift.String {
    get
  }
}
extension UICollectionView {
  public enum SupplementaryKind {
    case header
    case footer
    public static func == (a: UIKit.UICollectionView.SupplementaryKind, b: UIKit.UICollectionView.SupplementaryKind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public func registerSupplementaryClass(cellClass: UIKit.UICollectionReusableView.Type, forKind kind: UIKit.UICollectionView.SupplementaryKind)
}
public struct Gestalt {
  public enum DebugLevel : Swift.Int, Swift.Comparable {
    case none
    case testFlight
    case internalTesting
    case debugging
    public static func < (lhs: Gulliver.Gestalt.DebugLevel, rhs: Gulliver.Gestalt.DebugLevel) -> Swift.Bool
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public static var debugLevel: Gulliver.Gestalt.DebugLevel
  public static var runningOnSimulator: Swift.Bool {
    get
  }
  public static var isAttachedToDebugger: Swift.Bool
  public static func isOnMainThread()
  public static func ensureMainThread(message: Swift.String? = nil)
  public static var isExtension: Swift.Bool
  public static var isOnIPad: Swift.Bool
  public static var isOnIPhone: Swift.Bool
  public static var isTestflightBuild: Swift.Bool
  public static var isAppStoreBuild: Swift.Bool
  public static var isProductionBuild: Swift.Bool
  public static var osMajorVersion: Swift.Int
  public static var simulatorMachineName: Swift.String? {
    get
  }
  public static var simulatorSystemName: Swift.String? {
    get
  }
  public static var simulatorReleaseName: Swift.String? {
    get
  }
  public static var simulatorVersionName: Swift.String? {
    get
  }
  public static var simulatorCPUName: Swift.String? {
    get
  }
  public static var rawDeviceType: Swift.String {
    get
  }
  public static func convertRawDeviceTypeToModelName(_ raw: Swift.String) -> Swift.String?
  public static var deviceType: Swift.String
  public static var simulatorInfo: Swift.String {
    get
  }
  public static var isRunningUITests: Swift.Bool {
    get
  }
  public static var isRunningUnitTests: Swift.Bool
  public static func systemDirectoryURL(which: Foundation.FileManager.SearchPathDirectory) -> Foundation.URL
  public static var libraryURL: Foundation.URL
  public static var cachesURL: Foundation.URL
}
extension CGImage {
  public var isEmpty: Swift.Bool {
    get
  }
}
extension UIView {
  public enum SeparatorPosition : Swift.Int {
    case left
    case right
    case top
    case bottom
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public func addSeparator(side: UIKit.UIView.SeparatorPosition, color: UIKit.UIColor = UIColor.gray, size: CoreGraphics.CGFloat = 1.0)
  public func removeSeparator(side: UIKit.UIView.SeparatorPosition)
}
public func bridge<T>(_ obj: T) -> Swift.UnsafeRawPointer where T : AnyObject
public func bridge<T>(_ obj: T) -> Swift.UnsafeMutableRawPointer where T : AnyObject
public func bridge<T>(_ ptr: Swift.UnsafeRawPointer) -> T where T : AnyObject
public func bridgeRetained<T>(_ obj: T) -> Swift.UnsafeRawPointer where T : AnyObject
public func bridgeTransfer<T>(_ ptr: Swift.UnsafeRawPointer) -> T where T : AnyObject
extension NSObject {
  public var bridged: Swift.UnsafeRawPointer {
    get
  }
  public var bridgedMutable: Swift.UnsafeMutableRawPointer {
    get
  }
}
extension UnsafeMutableRawPointer {
  public func unbridge<T>() -> T where T : AnyObject
}
extension UnsafeMutablePointer {
  public func unbridge<T>() -> T where T : AnyObject
}
extension UIButton {
  public var text: Swift.String? {
    get
    set(newValue)
  }
  public var image: UIKit.UIImage? {
    get
    set(newValue)
  }
  public var textColor: UIKit.UIColor? {
    get
    set(newValue)
  }
  public var textFont: UIKit.UIFont? {
    get
    set(newValue)
  }
}
extension UIControl.Event : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
}
extension UIControl {
  public static var trackedEvents: [(UIKit.UIControl.Event, ObjectiveC.Selector, Swift.StaticString)]
  public func addClosure(for controlEvents: UIKit.UIControl.Event, closure: @escaping (UIKit.UIControl) -> Swift.Void)
  public func removeBlock(forControlEvents: UIKit.UIControl.Event)
  public func blockForEvent(_ event: UIKit.UIControl.Event) -> ((UIKit.UIControl) -> Swift.Void)?
  @objc dynamic public func fireClosureForTouchUpInside(sender: Swift.AnyObject?, event: UIKit.UIEvent)
  @objc dynamic public func fireClosureForTouchUpOutside(sender: Swift.AnyObject?, event: UIKit.UIEvent)
  @objc dynamic public func fireClosureForTouchDown(sender: Swift.AnyObject?, event: UIKit.UIEvent)
}
extension UICollectionView {
  public func registerCellClass(cellClass: UIKit.UICollectionViewCell.Type)
}
@objc @_inheritsConvenienceInitializers @available(iOS 9.0, *)
public class AttributedTableViewCell : UIKit.UITableViewCell {
  public var attributedLabel: UIKit.UILabel!
  public var attributedText: Foundation.NSAttributedString? {
    get
    set(newValue)
  }
  public class func attributedCell(reuseIdentifier: Swift.String? = nil, insets: UIKit.UIEdgeInsets = UIEdgeInsets(top: 2, left: 5, bottom: 2, right: 5)) -> Gulliver.AttributedTableViewCell
  @objc override dynamic public func awakeFromNib()
  public var edgeInsets: UIKit.UIEdgeInsets {
    get
    set(value)
  }
  @objc override dynamic open func didMoveToSuperview()
  @objc deinit
  @available(iOS 9.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers public class SA_TableViewCell : UIKit.UITableViewCell {
  public var dividerColor: UIKit.UIColor? {
    get
    set(newValue)
  }
  public var dividerView: UIKit.UIView?
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension UITableViewCell {
  open class var identifier: Swift.String {
    get
  }
  open class var nib: UIKit.UINib {
    get
  }
  open class var defaultNibName: Swift.String {
    get
  }
}
extension UITableView {
  public func register(cellClass: UIKit.UITableViewCell.Type)
}
@objc @_inheritsConvenienceInitializers public class ShowErrorLogButton : UIKit.UIButton {
  public var forceVisible: Swift.Bool {
    get
    set(value)
  }
  @objc dynamic public convenience init()
  @objc public func updateVisibility()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers open class ErrorLogDisplay : UIKit.UITableViewController {
  @discardableResult
  open class func present(in parent: UIKit.UIViewController) -> UIKit.UIViewController
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  open func reload()
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc deinit
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension NSData {
  public func compress(type: Foundation.Data.CompressionAlgorithm = .lzfse) -> Foundation.NSData?
  public func decompress(type: Foundation.Data.CompressionAlgorithm = .lzfse, maxSize: Swift.Int = 1024 * 1024 * 1024) -> Foundation.NSData?
}
extension Data {
  public enum CompressionAlgorithm {
    case zlib
    case lzfse
    public static func == (a: Foundation.Data.CompressionAlgorithm, b: Foundation.Data.CompressionAlgorithm) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public func compress(type: Foundation.Data.CompressionAlgorithm = .lzfse) -> Foundation.Data?
  public func decompress(type: Foundation.Data.CompressionAlgorithm = .lzfse) -> Foundation.Data?
}
extension UILabel {
  public var actualFontInUse: UIKit.UIFont? {
    get
  }
  public var currentAttributedText: Foundation.NSAttributedString? {
    get
  }
  public var textSize: CoreGraphics.CGSize {
    get
  }
}
extension ManagedObjectStore {
  public func removeDatabaseFile(completion: (() -> Swift.Void)? = nil)
  public func deleteAllData(entitiesToClear: [CoreData.NSEntityDescription]? = nil, completion: @escaping () -> Swift.Void)
}
@objc @_inheritsConvenienceInitializers open class XibHostedView : UIKit.UIView, UIKit.UITextFieldDelegate {
  open class func fromXIB() -> Gulliver.XibHostedView?
  @objc override dynamic open func awakeAfter(using aDecoder: Foundation.NSCoder) -> Any?
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public class MobileProvisionFile {
  public convenience init?(url: Foundation.URL?)
  public var properties: Foundation.NSDictionary!
  public static var `default`: Gulliver.MobileProvisionFile?
  public init?(data: Foundation.Data?)
  @objc deinit
}
